This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
content.js
manifest.json
popup.html
popup.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="content.js">
// --- NEW: This will now be our in-memory cache of persistent IDs ---
let processedIdsSet = new Set();

// --- NEW: Function to load already-processed IDs from persistent storage ---
function loadProcessedIds() {
    chrome.storage.local.get(['savedMemoryMessageIds'], (result) => {
        if (result.savedMemoryMessageIds && Array.isArray(result.savedMemoryMessageIds)) {
            processedIdsSet = new Set(result.savedMemoryMessageIds);
            console.log(`ChatGPT Memory Ext: Loaded ${processedIdsSet.size} previously processed message IDs.`);
        }
    });
}


// --- Main Listener for commands from the popup (no changes) ---
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.action === 'generateMemory' || request.action === 'remind') {
        sendPromptToChatGPT(request.prompt);
    }
});


// --- Function to send prompt to the ChatGPT UI (no changes) ---
function sendPromptToChatGPT(prompt) {
    const inputDiv = document.getElementById('prompt-textarea');
    if (!inputDiv) {
        console.error("ChatGPT Memory Ext: Could not find the chat input box.");
        return;
    }

    inputDiv.textContent = prompt;
    inputDiv.dispatchEvent(new Event('input', { bubbles: true }));

    setTimeout(() => {
        const sendButton = document.querySelector('button[data-testid="send-button"]');
        if (!sendButton) {
            console.error("ChatGPT Memory Ext: Could not find the send button.");
            return;
        }

        if (sendButton.disabled) {
            console.error("ChatGPT Memory Ext: Send button is still disabled after a delay.");
        } else {
            sendButton.click();
        }
    }, 250);
}


// --- Observer to watch for AI responses (no major changes to observer itself) ---
const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
        const processNode = (node) => {
            if (node.nodeType !== 1) return;
            const assistantMessages = Array.from(node.querySelectorAll('div[data-message-author-role="assistant"]'));
            if (node.matches('div[data-message-author-role="assistant"]')) {
                assistantMessages.push(node);
            }
            assistantMessages.forEach(processMessage);
        };
        mutation.addedNodes.forEach(processNode);
        if (mutation.type === 'attributes' && mutation.target.matches('.markdown')) {
            const assistantMessageNode = mutation.target.closest('div[data-message-author-role="assistant"]');
            if (assistantMessageNode) {
                processMessage(assistantMessageNode);
            }
        }
    });
});


// --- Function to process a potential message (MAJOR CHANGES HERE) ---
function processMessage(messageNode) {
    const messageId = messageNode.getAttribute('data-message-id');

    // --- FIX: Check against our now-persistent set of IDs ---
    if (!messageId || processedIdsSet.has(messageId)) {
        return;
    }

    const messageDiv = messageNode.querySelector('.markdown');
    if (!messageDiv) return;

    const messageText = messageDiv.innerText || "";

    if (messageText.includes('[START_MEMORY]') && messageText.includes('[END_MEMORY]')) {
        if (messageText.includes('[CONTEXT_UPDATE]')) {
            return;
        }
        
        // --- FIX: We add the ID to our in-memory set immediately to prevent race conditions ---
        processedIdsSet.add(messageId);

        const memoryContent = messageText.substring(
            messageText.indexOf('[START_MEMORY]') + '[START_MEMORY]'.length,
            messageText.indexOf('[END_MEMORY]')
        ).trim();

        const titleMatch = memoryContent.match(/Title:\s*(.*)/);
        const infoMatch = memoryContent.match(/Info:\s*([\s\S]*)/);
        
        if (titleMatch && infoMatch) {
            const newMemory = {
                id: new Date().toISOString(),
                title: titleMatch[1].trim(),
                info: memoryContent.substring(infoMatch.index + 'Info:'.length).trim(),
                url: window.location.href
            };

            // --- FIX: Save both the memory AND the message ID to persistent storage ---
            chrome.storage.local.get(['memories', 'savedMemoryMessageIds'], (result) => {
                const memories = result.memories || [];
                // Use the in-memory set to create the new array to be saved.
                const savedIds = Array.from(processedIdsSet);

                memories.push(newMemory);

                chrome.storage.local.set({ 
                    memories: memories, 
                    savedMemoryMessageIds: savedIds // Persist the updated list of IDs
                }, () => {
                    console.log('Successfully saved memory and its ID:', messageId);
                    chrome.runtime.sendMessage({ action: 'memory_created' });
                    chrome.notifications.create({
                        type: 'basic',
                        iconUrl: 'icons/icon48.png',
                        title: 'ChatGPT Memory Saved!',
                        message: `The memory "${newMemory.title}" has been added.`
                    });
                });
            });
        }
    }
}


// --- Function to start the observer ---
function startObserver() {
    const mainContent = document.querySelector('main');
    if (mainContent) {
        observer.observe(mainContent, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['class']
        });
        console.log("ChatGPT Memory Ext: Robust observer started.");
    } else {
        setTimeout(startObserver, 1000);
    }
}

// --- NEW: On script start, load the IDs first, then start observing ---
loadProcessedIds();
startObserver();
</file>

<file path="manifest.json">
{
  "manifest_version": 3,
  "name": "ChatGPT Memory Bank",
  "version": "1.0",
  "description": "Saves and recalls important information for ChatGPT conversations.",
  "permissions": [
    "storage",
    "activeTab",
    "scripting",
    "notifications"
  ],
  "host_permissions": [
    "https://chat.openai.com/*",
    "https://chatgpt.com/*"
  ],
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icons/icon16.png",
      "48": "icons/icon48.png",
      "128": "icons/icon128.png"
    }
  },
  "icons": {
      "16": "icons/icon16.png",
      "48": "icons/icon48.png",
      "128": "icons/icon128.png"
  },
  "content_scripts": [
    {
      "matches": ["https://chat.openai.com/*", "https://chatgpt.com/*"],
      "js": ["content.js"]
    }
  ]
}
</file>

<file path="popup.html">
<!DOCTYPE html>
<html>
<head>
  <title>ChatGPT Memory Bank</title>
  <style>
    body { font-family: sans-serif; width: 400px; padding: 10px; font-size: 14px; }
    h3 { margin-top: 15px; margin-bottom: 5px; }
    button { padding: 8px; margin-bottom: 10px; cursor: pointer; }
    #generate-buttons button { width: 100%; }

    #memory-list { max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 5px; }
    .memory-item { padding: 8px; border-bottom: 1px solid #eee; }
    .memory-title { font-weight: bold; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
    .memory-title:hover { background-color: #f0f0f0; }
    .memory-info { display: none; margin-top: 8px; padding: 8px; background-color: #f9f9f9; border-radius: 4px; }
    .memory-item.expanded .memory-info { display: block; }
    
    /* --- THE FIX IS HERE --- */
    /* This new rule targets the <pre> tag directly to enforce text wrapping. */
    .memory-info pre {
      white-space: pre-wrap;   /* Allows text to wrap to the next line */
      overflow-wrap: break-word; /* Breaks long words that would otherwise overflow */
      font-size: 13px;         /* Keeps font consistent with edit textarea */
      margin: 0;               /* Resets default <pre> tag margins */
    }
    /* --- END FIX --- */

    .memory-actions { margin-top: 8px; text-align: right; }
    .memory-actions button { font-size: 12px; padding: 4px 8px; margin-left: 5px; }

    .edit-textarea { width: 98%; min-height: 80px; margin-top: 5px; font-family: inherit; font-size: 13px; }
  </style>
</head>
<body>
  <h3>Saved Memories</h3>
  <div id="memory-list">
    <!-- Memories will be loaded here by JavaScript -->
  </div>
  <button id="remindBtn" style="width: 100%; margin-top: 10px;">Remind ChatGPT of Selected</button>
  <h3>Generate Memory</h3>
  <div style="margin-bottom: 8px;">
    <input id="customInstruction" type="text" placeholder="Enter specific instruction (optional)" style="width: 100%; padding: 6px; font-size: 13px;" />
  </div>
  <div id="generate-buttons" style="display: flex; flex-direction: row; justify-content: space-between; margin-bottom: 5px;">
    <button id="saveLastBtn" style="flex: 1; margin-right: 5px;">Save Last Exchange</button>
    <button id="saveChatBtn" style="flex: 1; margin-right: 5px;">Save Whole Chat</button>
  </div>
  <script src="popup.js"></script>
</body>
</html>
</file>

<file path="popup.js">
// Add this at the top to inject custom styles for ChatGPT-like dark theme
(function injectChatGPTStyles() {
    const style = document.createElement('style');
    style.innerHTML = `
        body, html {
            background: #343541 !important;
            color: #ececf1 !important;
            font-family: 'Segoe UI', 'Inter', 'Arial', sans-serif;
            margin: 0;
            min-width: 340px;
            min-height: 420px;
            box-sizing: border-box;
        }
        #memory-list {
            background: #343541;
            border-radius: 14px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.18);
            padding: 0 0 8px 0;
        }
        .memory-item {
            background: #393945;
            border-radius: 12px;
            margin: 10px 12px 0 12px;
            padding: 10px 12px 8px 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.10);
            border: none;
            transition: background 0.2s;
        }
        .memory-item.expanded {
            background: #444654;
        }
        .memory-title {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            border-radius: 8px;
            transition: background 0.18s;
        }
        .memory-title:hover {
            background: rgba(255,255,255,0.07);
        }
        .memory-title input[type="checkbox"] {
            accent-color: #23232b;
            margin-right: 8px;
            transform: scale(0.9);
        }
        .memory-info {
            background: #23232b;
        }
        .memory-info pre, .memory-info textarea {
            background: #23232b;
            border: none;
            border-radius: 10px;
            font-size: 13px;
            padding: 8px;
            margin: 0 0 4px 0;
            width: 100%;
            box-sizing: border-box;
            font-family: 'Fira Mono', 'Consolas', monospace;
        }
        .memory-info textarea {
            min-height: 60px;
            resize: vertical;
        }
        .memory-actions {
            display: flex;
            gap: 6px;
            margin-top: 4px;
        }
        .memory-actions button {
            background: #23232b;
            color: #ececf1;
            border: none;
            border-radius: 10px;
            padding: 4px 14px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.18s, color 0.18s;
            margin-right: 0;
            outline: none;
            box-shadow: none;
        }
        .memory-actions button:hover {
            background: #393945;
            color: #fff;
        }
        .edit-title-input {
            background: #23232b;
            color: #ececf1;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            padding: 4px 8px;
            width: 90%;
        }
        #memorySearch {
            background: #23232b;
            color: #ececf1;
            border: none;
            border-radius: 10px;
            font-size: 13px;
            padding: 6px 10px;
            margin-bottom: 8px;
        }
        #customInstruction {
            background: #23232b;
            color: #ececf1;
            border: none;
            border-radius: 10px;
            font-size: 13px;
            padding: 6px 10px;
            margin-bottom: 8px;
            width: 100%;
            box-sizing: border-box;
        }
        .memory-url a {
            color: #0066cc;
            text-decoration: underline;
        }
        .memory-url a:hover {
            color: #004999;
        }
        ::selection {
            background: #10a37f44;
        }
        button:active {
            background: #17171c;
        }
        /* Style for the main action buttons */
        .main-action-btn {
            background: #23232b;
            color: #ececf1;
            border: none;
            border-radius: 12px;
            padding: 8px 18px;
            font-size: 14px;
            font-weight: 500;
            margin: 0 8px 14px 0;
            box-shadow: none;
            transition: background 0.18s, color 0.18s;
            outline: none;
            display: inline-block;
        }
        .main-action-btn:hover {
            background: #393945;
            color: #fff;
        }
        .main-action-btn:active {
            background: #17171c;
        }
        .main-action-btn:last-child {
            margin-right: 0;
        }
        /* Add spacing for the top action bar */
        #main-action-bar {
            display: flex;
            flex-wrap: wrap;
        }
    `;
    document.head.appendChild(style);
})();

// --- PROMPTS (No changes here) ---
const PROMPT_LAST_EXCHANGE = `[SYSTEM_COMMAND]\nAnalyze ONLY the last user message and your last response. Your task is to extract the most critical, reusable piece of information, a key decision, or a core fact that should be remembered for future context.\n\nOnly include important information that was actually sent by either you or me, nothing you deduced or inferred.\n\nStrictly format your output as a memory object within the specified markers. Do not add any conversational text or explanations before or after the markers.\n\nThe format is:\n[START_MEMORY]\nTitle: [A concise, descriptive title for the memory, 5-10 words]\nInfo: [A detailed but brief summary of the information to be remembered. Focus on the essential facts, figures, or instructions.]\n[END_MEMORY]\n\nAfter you provide this formatted memory, I will continue the conversation as normal.`;
const PROMPT_WHOLE_CHAT = `[SYSTEM_COMMAND]\nAnalyze our ENTIRE conversation history up to this point. Your task is to identify and synthesize the most globally important facts, user preferences, overarching goals, or key decisions that are essential for maintaining context throughout a long project. Ignore trivial details and focus on foundational information.\n\nOnly include important information that was actually sent by either you or me, nothing you deduced or inferred.\n\nStrictly format your output as a memory object within the specified markers. Do not add any conversational text or explanations before or after the markers.\n\nThe format is:\n[START_MEMORY]\nTitle: [A concise, descriptive title for the overall chat memory, 5-10 words]\nInfo: [A bulleted or paragraph summary of the most critical, high-level information from the entire chat that must be remembered.]\n[END_MEMORY]\n\nAfter you provide this formatted memory, I will continue the conversation as normal.`;

// New: Prompts with custom instruction placeholder
function buildPromptWithInstruction(basePrompt, instruction) {
    if (!instruction || !instruction.trim()) return basePrompt;
    return basePrompt + `\n\n[EXTRA_INSTRUCTION]\n${instruction.trim()}\n[END_EXTRA_INSTRUCTION]`;
}

// --- EVENT LISTENERS ---
document.addEventListener('DOMContentLoaded', loadMemories);

// Add search input above memory list
document.addEventListener('DOMContentLoaded', () => {
    const searchDiv = document.createElement('div');
    searchDiv.style.marginBottom = '8px';
    searchDiv.innerHTML = `<input id="memorySearch" type="text" placeholder="Search memories..." style="width: 100%; padding: 6px; font-size: 13px;" />`;
    const memoryList = document.getElementById('memory-list');
    memoryList.parentNode.insertBefore(searchDiv, memoryList);
    document.getElementById('memorySearch').addEventListener('input', filterMemories);
});

// Main action buttons
function getPromptWithOptionalInstruction(basePrompt) {
    const instruction = document.getElementById('customInstruction').value;
    return buildPromptWithInstruction(basePrompt, instruction);
}
document.getElementById('saveLastBtn').addEventListener('click', () => {
    const prompt = getPromptWithOptionalInstruction(PROMPT_LAST_EXCHANGE);
    sendMessageToContentScript({ action: 'generateMemory', prompt });
});
document.getElementById('saveChatBtn').addEventListener('click', () => {
    const prompt = getPromptWithOptionalInstruction(PROMPT_WHOLE_CHAT);
    sendMessageToContentScript({ action: 'generateMemory', prompt });
});

// Listen for updates from the content script to refresh the list
chrome.runtime.onMessage.addListener((message) => {
    if (message.action === 'memory_created') {
        loadMemories();
    }
});

// --- DYNAMIC EVENT LISTENER FOR MEMORY LIST ---
// Using event delegation to handle clicks on future elements
document.getElementById('memory-list').addEventListener('click', (e) => {
    // Prevent toggling memory tile when clicking the checkbox
    if (e.target.matches('.memory-checkbox')) {
        e.stopPropagation();
        return;
    }
    const memoryItem = e.target.closest('.memory-item');
    if (!memoryItem) return;
    
    const memoryId = memoryItem.dataset.id;

    // Click on title to expand/collapse
    if (e.target.matches('.memory-title') || e.target.closest('.memory-title')) {
        memoryItem.classList.toggle('expanded');
    }

    // Click on delete button
    if (e.target.matches('.delete-btn')) {
        if (confirm('Are you sure you want to delete this memory?')) {
            deleteMemory(memoryId);
        }
    }

    // Click on edit button
    if (e.target.matches('.edit-btn')) {
        toggleEditMode(memoryItem, true);
    }

    // Click on save edit button
    if (e.target.matches('.save-edit-btn')) {
        saveMemoryChanges(memoryItem, memoryId);
    }

    // Click on cancel edit button
    if (e.target.matches('.cancel-edit-btn')) {
        toggleEditMode(memoryItem, false);
    }

    // Click on go to chat button
    if (e.target.matches('.go-to-chat-btn')) {
        const memories = JSON.parse(localStorage.getItem('memoriesCache') || '[]');
        const memory = memories.find(m => m.id === memoryId);
        if (memory && memory.url) {
            window.open(memory.url, '_blank');
        } else {
            // fallback: try to get from DOM
            const urlDiv = memoryItem.querySelector('.memory-url a');
            if (urlDiv) window.open(urlDiv.href, '_blank');
        }
    }
});

// --- CORE FUNCTIONS ---

let allMemoriesCache = [];

function loadMemories() {
    chrome.storage.local.get(['memories'], (result) => {
        let memories = result.memories || [];
        // Sort newest to oldest (by id, which is ISO string)
        memories.sort((a, b) => b.id.localeCompare(a.id));
        allMemoriesCache = memories;
        localStorage.setItem('memoriesCache', JSON.stringify(memories));
        renderMemories(memories);
    });
}

function renderMemories(memories) {
    const memoryListDiv = document.getElementById('memory-list');
    memoryListDiv.innerHTML = '';
    if (memories.length === 0) {
        memoryListDiv.innerHTML = '<p style="padding: 10px; text-align: center;">No memories saved yet.</p>';
        return;
    }
    memories.forEach(memory => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'memory-item';
        itemDiv.dataset.id = memory.id;
        itemDiv.innerHTML = `
            <div class="memory-title">
                <span>
                    <input type="checkbox" class="memory-checkbox" />
                    ${memory.title}
                </span>
                <span></span>
            </div>
            <div class="memory-info">
                <pre>${memory.info}</pre>
                ${memory.url ? `<div class='memory-url' style='margin-top:6px; font-size:12px; color:#555; word-break:break-all;'>URL: <a href='${memory.url}' target='_blank'>${memory.url}</a></div>` : ''}
            </div>
            <div class="memory-actions">
                <button class="edit-btn">Edit</button>
                <button class="delete-btn">Delete</button>
                <button class="go-to-chat-btn" ${memory.url ? '' : 'style="display:none;"'}>Go to Chat</button>
                <button class="save-edit-btn" style="display:none;">Save</button>
                <button class="cancel-edit-btn" style="display:none;">Cancel</button>
            </div>
        `;
        memoryListDiv.appendChild(itemDiv);
    });
}

function deleteMemory(id) {
    chrome.storage.local.get(['memories'], (result) => {
        let memories = result.memories || [];
        memories = memories.filter(mem => mem.id !== id);
        chrome.storage.local.set({ memories }, () => {
            loadMemories(); // Refresh the list
        });
    });
}

function toggleEditMode(itemDiv, isEditing) {
    const titleSpan = itemDiv.querySelector('.memory-title span:first-child');
    const infoPre = itemDiv.querySelector('.memory-info pre');
    
    const editBtn = itemDiv.querySelector('.edit-btn');
    const deleteBtn = itemDiv.querySelector('.delete-btn');
    const saveBtn = itemDiv.querySelector('.save-edit-btn');
    const cancelBtn = itemDiv.querySelector('.cancel-edit-btn');

    if (isEditing) {
        // Switch to edit mode
        const currentTitle = titleSpan.innerText;
        const currentInfo = infoPre.innerText;
        
        titleSpan.innerHTML = `<input type="text" class="edit-title-input" value="${currentTitle}" />`;
        infoPre.innerHTML = `<textarea class="edit-textarea">${currentInfo}</textarea>`;
        
        itemDiv.classList.add('expanded'); // Ensure info is visible
        editBtn.style.display = 'none';
        deleteBtn.style.display = 'none';
        saveBtn.style.display = 'inline-block';
        cancelBtn.style.display = 'inline-block';
    } else {
        // Cancel edit mode - just reload the list to reset everything
        loadMemories();
    }
}

function saveMemoryChanges(itemDiv, id) {
    const newTitle = itemDiv.querySelector('.edit-title-input').value;
    const newInfo = itemDiv.querySelector('.edit-textarea').value;

    if (!newTitle.trim()) {
        alert("Title cannot be empty.");
        return;
    }

    chrome.storage.local.get(['memories'], (result) => {
        let memories = result.memories || [];
        const memoryIndex = memories.findIndex(mem => mem.id === id);
        
        if (memoryIndex !== -1) {
            memories[memoryIndex].title = newTitle;
            memories[memoryIndex].info = newInfo;
        }

        chrome.storage.local.set({ memories }, () => {
            loadMemories(); // Refresh the list with the updated data
        });
    });
}

function handleRemind() {
    const selectedMemories = [];
    document.querySelectorAll('.memory-checkbox:checked').forEach(checkbox => {
        const itemDiv = checkbox.closest('.memory-item');
        const id = itemDiv.dataset.id;
        // Read memory from storage to ensure we have the latest version
        chrome.storage.local.get(['memories'], (result) => {
            const memory = (result.memories || []).find(m => m.id === id);
            if (memory) {
                selectedMemories.push(memory);
            }
        });
    });
    
    // Use a timeout to wait for the async storage reads to complete
    setTimeout(() => {
        if (selectedMemories.length > 0) {
            // Only include the info(s), not the titles
            let memoryText = selectedMemories.map(m => m.info).join('\n\n');
            const remindPrompt = `[CONTEXT_UPDATE]\nThe following are memories of our previous conversations. I am providing them to restore your context. Read and internalize them. Do not treat this as a question or a task.\n\nOnce you have processed this information, your ONLY response should be: "Understood. My context is updated. Please proceed."\n\n--- START MEMORIES ---\n\n${memoryText}\n\n--- END MEMORIES ---\n\nNow, provide only the confirmation message and await my next real prompt.`;
            sendMessageToContentScript({ action: 'remind', prompt: remindPrompt });
        } else {
            alert('Please select at least one memory to remind ChatGPT.');
        }
    }, 100);
}

function filterMemories() {
    const query = document.getElementById('memorySearch').value.trim().toLowerCase();
    if (!query) {
        renderMemories(allMemoriesCache);
        return;
    }
    const filtered = allMemoriesCache.filter(m =>
        (m.title && m.title.toLowerCase().includes(query)) ||
        (m.info && m.info.toLowerCase().includes(query))
    );
    renderMemories(filtered);
}

function sendMessageToContentScript(message) {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        chrome.tabs.sendMessage(tabs[0].id, message);
    });
}

// Add main action bar wrapper and button classes on DOMContentLoaded

document.addEventListener('DOMContentLoaded', () => {
    // Wrap the two main buttons in a styled bar (remindBtn will be moved)
    const saveLastBtn = document.getElementById('saveLastBtn');
    const saveChatBtn = document.getElementById('saveChatBtn');
    const remindBtn = document.getElementById('remindBtn');
    if (saveLastBtn && saveChatBtn) {
        [saveLastBtn, saveChatBtn].forEach(btn => {
            btn.classList.add('main-action-btn');
            btn.style.width = '100%';
            btn.style.margin = '0';
            btn.style.display = 'inline-block';
        });
        let bar = document.createElement('div');
        bar.id = 'main-action-bar';
        bar.style.display = 'flex';
        bar.style.flexDirection = 'row';
        bar.style.gap = '12px';
        bar.style.width = '100%';
        saveLastBtn.parentNode.insertBefore(bar, saveLastBtn);
        bar.appendChild(saveLastBtn);
        bar.appendChild(saveChatBtn);
    }
    // Move remindBtn to the bottom of the memory list
    if (remindBtn) {
        remindBtn.classList.add('main-action-btn');
        remindBtn.style.width = '100%';
        remindBtn.style.margin = '18px 0 0 0';
        remindBtn.style.display = 'block';
        remindBtn.onclick = handleRemind;
        // const memoryList = document.getElementById('memory-list');
        // if (memoryList && memoryList.parentNode) {
        //     memoryList.parentNode.appendChild(remindBtn);
        // }
    }
});
</file>

</files>
